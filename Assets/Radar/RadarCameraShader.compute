#pragma kernel generate_buffer
#pragma kernel clear_buffer
#pragma kernel generate_texture
#pragma kernel blur

#define PI 3.14159265358979323846;

Texture2D<float4> color_texture;
Texture2D<float> depth_texture;
RWTexture2D<float4> result_texture;
RWTexture2D<float4> blur_texture;
RWStructuredBuffer<uint> buffer;

float color_norm_const;
float2 cam_angle;
float near, far;
int cam_width, cam_height;
int texture_width, texture_height;
float fragment_length;
float cur_angle;

int blur_radius;

float depth_to_normal(const float depth)
{
    return 2 * near * far / (far + near + (far - near) * (2 * depth - 1));
}

float get_distance(uint2 id)
{
    return depth_to_normal(depth_texture[id.xy]) * sqrt(
        1.0 +
        pow(tan(cam_angle.x / 2) * (2.0 * id.x - cam_width) / cam_width, 2) +
        pow(tan(cam_angle.y / 2) * (2.0 * id.y - cam_height) / cam_height, 2)
        );
}

float get_value_for_buffer(const uint3 id)
{
    return color_texture[id.xy].x  * (1000000000.0 / cam_height);
}

float get_color(float angle, const int fragment_id)
{
    if (angle > cam_angle.x)
    {
        return 0.0;
    }
    
    int angle_id = tan(angle - cam_angle.x / 2) / tan(cam_angle.x / 2) / 2 * cam_width;
    angle_id += cam_width / 2;
    
    return color_norm_const * buffer[fragment_id * cam_width + angle_id] /  (1000000000.0 / cam_height);
}

[numthreads(8,8,1)]
void generate_texture (uint3 id : SV_DispatchThreadID)
{
    float pi = PI;
    float angle = 1.0 * id.x / texture_width * 2 * pi;
    float absolute_angle = (angle + cur_angle) % (2 * pi);
    int x = (absolute_angle / 2 / pi * texture_width) % texture_width;
    float green_val = angle / cam_angle.x / 3;
    result_texture[int2(x, id.y)] = float4(get_color(angle, id.y), green_val, 0, 0);
}

[numthreads(8,8,1)]
void generate_buffer (uint3 id : SV_DispatchThreadID)
{
    int val = get_distance(id) / fragment_length;
    InterlockedAdd(buffer[val * cam_width + id.x], get_value_for_buffer(id));
}

[numthreads(8,8,1)]
void clear_buffer(uint3 id: SV_DispatchThreadID)
{
    buffer[id.y * cam_width + id.x] = 0;
}

float4 get_result(int2 id, int dx, int dy) 
{
    int x = (id.x + dx + texture_width) % texture_width;
    int y = max(0, min(texture_height - 1, id.y + dy));
    return result_texture[id.xy];
}

[numthreads(8,8,1)]
void blur(uint3 id: SV_DispatchThreadID)
{
    float pi = PI;
    int x = (id.x + cur_angle / 2 / pi * texture_width) % texture_width;
    int2 pixel_id = int2(x, id.y);
    blur_texture[pixel_id] = 0;
    for (int dx = -blur_radius; dx <= blur_radius; dx++)
    {
        for (int dy = -blur_radius; dy <= blur_radius; dy++)
        {
            blur_texture[pixel_id] += get_result(pixel_id, dx, dy);
        }
    }
    blur_texture[pixel_id] /= pow(2 * blur_radius + 1, 2);
}
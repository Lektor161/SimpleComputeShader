#pragma kernel generate_buffer
#pragma kernel clear_buffer
#pragma kernel generate_texture
#pragma kernel blur

#define PI 3.14159265358979323846;

Texture2D<float4> color_texture;
Texture2D<float> depth_texture;
RWTexture2D<float4> result_texture;
RWTexture2D<float4> blur_texture;
RWTexture2D<uint> buffer;

float color_norm_const;
float2 cam_angle;
float near, far;
uint cam_width, cam_height;
uint texture_width, texture_height;
float fragment_length;
uint fragment_count;
//float cur_angle;
uint x_shift;
uint x_width;
int2 blurxy;

float delta;

float depth_to_normal(const float depth)
{
    return 2 * near * far / (far + near + (far - near) * (2 * depth - 1));
}

float get_distance(uint2 id)
{
    return depth_to_normal(depth_texture[id.xy]) * sqrt(
        1.0 +
        pow(tan(cam_angle.x / 2) * (2.0 * id.x - cam_width) / cam_width, 2) +
        pow(tan(cam_angle.y / 2) * (2.0 * id.y - cam_height) / cam_height, 2)
        );
}

float get_value_for_buffer(const uint3 id)
{
    return color_texture[id.xy].x  * (1000000000.0 / cam_height);
}

float get_color(const float angle, float y)
{
    if (angle > cam_angle.x)
    {
        return 0.0;
    }
    
    int angle_id = tan(angle - cam_angle.x / 2) / tan(cam_angle.x / 2) / 2 * cam_width;
    angle_id += cam_width / 2;

    y *= fragment_count;
    int y1 = y;
    int y2 = y1 + 1;
    const float val = (y - y1) * buffer[uint2(angle_id, y1)] + (y2 - y) * buffer[uint2(angle_id, y2)];
    return color_norm_const * buffer[uint2(angle_id, y1)] / (1000000000.0 / cam_height);
}

[numthreads(8,8,1)]
void generate_texture (uint3 id : SV_DispatchThreadID)
{
    float pi = PI;
    float angle = 1.0 * id.x / texture_width * 2 * pi;
    int x = (x_shift + id.x) % texture_width;
    float green_val = 0.3;
    result_texture[uint2(x, id.y)] = float4(get_color(angle, 1.0 * id.y / texture_height), green_val, 0, 0);
}

bool check(uint3 id)
{
    if (id.y < 1) return false;
    return abs(color_texture[id.xy].y - color_texture[uint2(id.x, id.y - 1)].y) < 1.0 / 1000;
}

[numthreads(8,8,1)]
void generate_buffer (uint3 id : SV_DispatchThreadID)
{
    //if (id.y == cam_height)
    //{
    //    buffer[id.xy] = (1000000000.0 / cam_height);
    //    return;
    //}
    uint val = get_distance(id.xy) / fragment_length;
    //if (check(id))
    //{
    //    //InterlockedAdd(buffer[id.xy], (1000000000.0 / cam_height));
    //    InterlockedAdd(buffer[id.xy], get_value_for_buffer(id));
    //}
    //return;
    
    if (check(id))
    {
        uint val2 = get_distance(uint2(id.x, id.y - 1)) / fragment_length;
        uint min_val = min(val, val2);
        uint max_val = max(val, val2);
        if (max_val > min_val + texture_height / 100) return;
        for (uint t = min_val + 1; t <= max_val; t++)
        {
            InterlockedAdd(buffer[uint2(id.x, t)], get_value_for_buffer(id));
        }
        return;
    }
    InterlockedAdd(buffer[uint2(id.x, val)], get_value_for_buffer(id));
}

[numthreads(8,8,1)]
void clear_buffer(uint3 id: SV_DispatchThreadID)
{
    buffer[id.xy] = 0;
}

float4 get_result(int2 id, const int dx, const int dy) 
{
    uint x = (id.x + dx + texture_width) % texture_width;
    uint y = max(0, min(texture_height - 1, id.y + dy));
    return result_texture[uint2(x, y)];
}

[numthreads(8,8,1)]
void blur(uint3 id: SV_DispatchThreadID)
{
    /*
    const float pi = PI;
    uint x = (id.x + cur_angle / 2 / pi * texture_width) % texture_width;
    const int2 pixel_id = int2(x, id.y);
    blur_texture[pixel_id] = 0;
    for (int dx = -blurxy.x; dx <= blurxy.x; dx++)
    {
        for (int dy = -blurxy.y; dy <= blurxy.y; dy++)
        {
            blur_texture[pixel_id] += get_result(pixel_id, dx, dy);
        }
    }
    blur_texture[pixel_id] /= (2 * blurxy.x + 1) * (2 * blurxy.y + 1);
    */
}
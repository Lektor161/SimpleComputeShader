#pragma kernel generate_buffer
#pragma kernel clear_buffer
#pragma kernel generate_texture

#define PI 3.14159265358979323846;

Texture2D<float4> color_texture;
Texture2D<float> depth_texture;
RWTexture2D<float4> result_texture;
RWStructuredBuffer<uint> buffer;

float near, far;
float2 cam_angle;
float cur_angle;
int cam_width, cam_height;
int texture_width, texture_height;
float fragment_length;
int fragment_num;

float max_radius;

float depth_to_normal(const float depth)
{
    return 2 * near * far / (far + near + (far - near) * (2 * depth - 1));
}

float get_distance(uint2 id)
{
    return depth_to_normal(depth_texture[id.xy]) * sqrt(
        1.0 +
        pow(tan(cam_angle.x / 2) * (2.0 * id.x - cam_width) / cam_width, 2) +
        pow(tan(cam_angle.y / 2) * (2.0 * id.y - cam_height) / cam_height, 2)
        );
}

float get_value_for_buffer(const uint3 id)
{
    return color_texture[id.xy].x  * (1000000000.0 / cam_height);
}

float get_color(float angle, const int fragment_id)
{
    if (angle > cam_angle.x)
    {
        return 0.0;
    }
    
    //int angle_id = angle / cam_angle.x * cam_width;
    int angle_id = tan(angle - cam_angle.x / 2) / tan(cam_angle.x / 2) / 2 * cam_width;
    angle_id += cam_width / 2;
    
    return 0.1 * buffer[fragment_id * cam_width + angle_id] /  (1000000000.0 / cam_height);
}

float get_angle(const float x, const float y)
{
    const float pi = PI;
    const float r = sqrt(x * x + y * y);
    float angle = 2.0 * atan(y / (r + x));
    return (angle + 2 * pi) % (2 * pi);
}

[numthreads(8,8,1)]
void generate_texture (uint3 id : SV_DispatchThreadID)
{
    const float x = 0.5 * texture_width - id.x;
    const float y = 0.5 * texture_height - id.y;

    const float radius = sqrt(x * x + y * y);
    if (radius > max_radius)
    {
        return;
    }
    const float pi = PI;
    float angle = get_angle(x, y);
    angle = (2.5 * pi - angle) % (2 * pi);
    angle = (2 * pi + angle - cur_angle) % (2 * pi);
    if (angle > cam_angle.x)
    {
        return;
    }
    result_texture[id.xy] = float4(get_color(angle, radius / max_radius * fragment_num), angle / cam_angle.x / 2, 0, 0);
}

[numthreads(8,8,1)]
void generate_buffer (uint3 id : SV_DispatchThreadID)
{
    int val = get_distance(id) / fragment_length;
    InterlockedAdd(buffer[val * cam_width + id.x], get_value_for_buffer(id));
}



[numthreads(8,8,1)]
void clear_buffer(uint3 id: SV_DispatchThreadID)
{
    buffer[id.y * cam_width + id.x] = 0;
}